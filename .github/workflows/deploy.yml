name: Library API - Complete Deploy Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  DOCKER_IMAGE_NAME: library-api
  PROJECT_DIR: ./LibraryOnlineRentalSystem
  DOTNET_VERSION: '8.0.x'  # Mantendo 8.0 como estava originalmente

jobs:
  # Job 1: Build e Testes
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Cache .NET packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}

      - name: Restore dependencies
        working-directory: ${{ env.PROJECT_DIR }}
        run: dotnet restore

      - name: Build
        working-directory: ${{ env.PROJECT_DIR }}
        run: dotnet build --no-restore --configuration Release

      - name: Test
        working-directory: ${{ env.PROJECT_DIR }}
        run: dotnet test --no-build --configuration Release --verbosity normal --logger trx --results-directory "TestResults"

      # Upload dos resultados dos testes para anÃ¡lise
      - name: Upload Test Results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: ${{ env.PROJECT_DIR }}/TestResults/*.trx

  # Job 2: Security Scan (somente em PRs)
  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name == 'pull_request'
    timeout-minutes: 15

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Build Docker Image for Testing
        working-directory: ${{ env.PROJECT_DIR }}
        run: docker build -t ${{ env.DOCKER_IMAGE_NAME }}:test .

      - name: Create test environment
        run: |
          # Create temporary docker-compose for testing
          cat > docker-compose.test.yml << 'EOF'
          services:
            app:
              image: library-api:test
              ports:
                - "8081:5000"
              environment:
                - ASPNETCORE_ENVIRONMENT=Development
                - ASPNETCORE_URLS=http://+:5000
                - ConnectionStrings__LibraryDatabase=Server=mysql;Port=3306;Database=librarydb;User=root;Password=testpass;
                - Keycloak__Authority=http://keycloak:8080/realms/library
                - Keycloak__Audience=library-client
                - Keycloak__ClientId=library-client
                - Keycloak__ClientSecret=test-secret
              depends_on:
                - mysql
            mysql:
              image: mysql:8.0
              environment:
                - MYSQL_ROOT_PASSWORD=testpass
                - MYSQL_DATABASE=librarydb
              tmpfs:
                - /var/lib/mysql
          EOF

      - name: Start test services
        run: |
          docker-compose -f docker-compose.test.yml up -d
          sleep 30

      - name: Run basic security scan
        run: |
          # Simple security check
          docker run --rm --network container:$(docker-compose -f docker-compose.test.yml ps -q app) \
            owasp/zap2docker-stable zap-baseline.py \
            -t http://localhost:5000 \
            -I -d || echo "Security scan completed"

      - name: Cleanup test environment
        if: always()
        run: |
          docker-compose -f docker-compose.test.yml down -v || true

  # Job 3: Deploy para Staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Deploy to Staging Server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_PRIVATE_KEY }}
          port: ${{ secrets.STAGING_PORT || 22 }}
          script: |
            # Create staging directory
            mkdir -p ~/library-api-staging
            cd ~/library-api-staging

            # Clone/update repository
            if [ -d ".git" ]; then
              git pull origin develop
            else
              git clone -b develop https://github.com/${{ github.repository }}.git .
            fi

            # Create staging docker-compose
            cat > docker-compose.staging.yml << 'EOF'
            services:
              app:
                build:
                  context: ${{ env.PROJECT_DIR }}
                  dockerfile: Dockerfile
                ports:
                  - "8081:5000"
                environment:
                  - ASPNETCORE_ENVIRONMENT=Staging
                  - ASPNETCORE_URLS=http://+:5000
                  - ConnectionStrings__LibraryDatabase=Server=mysql;Port=3306;Database=librarydb_staging;User=root;Password=${{ secrets.STAGING_MYSQL_PASSWORD }};
                  - Keycloak__Authority=http://keycloak:8080/realms/library
                  - Keycloak__Audience=library-client
                  - Keycloak__ClientId=library-client
                  - Keycloak__ClientSecret=${{ secrets.STAGING_KEYCLOAK_SECRET }}
                depends_on:
                  - mysql
                  - keycloak
                restart: unless-stopped
                volumes:
                  - /var/log/library-api-staging:/app/logs

              keycloak:
                image: quay.io/keycloak/keycloak:latest
                ports:
                  - "8082:8080"
                environment:
                  - KEYCLOAK_ADMIN=admin
                  - KEYCLOAK_ADMIN_PASSWORD=${{ secrets.STAGING_KEYCLOAK_ADMIN_PASSWORD }}
                  - KC_DB=mysql
                  - KC_DB_URL=jdbc:mysql://mysql:3306/keycloak_staging
                  - KC_DB_USERNAME=root
                  - KC_DB_PASSWORD=${{ secrets.STAGING_MYSQL_PASSWORD }}
                command: start-dev
                depends_on:
                  - mysql
                restart: unless-stopped
                volumes:
                  - keycloak_staging_data:/opt/keycloak/data

              mysql:
                image: mysql:8.0
                ports:
                  - "3307:3306"
                environment:
                  - MYSQL_ROOT_PASSWORD=${{ secrets.STAGING_MYSQL_PASSWORD }}
                  - MYSQL_DATABASE=librarydb_staging
                volumes:
                  - mysql_staging_data:/var/lib/mysql
                  - ./init-staging-db.sql:/docker-entrypoint-initdb.d/init-staging-db.sql
                restart: unless-stopped

            volumes:
              mysql_staging_data:
              keycloak_staging_data:
            EOF

            # Create database initialization script
            cat > init-staging-db.sql << 'EOF'
            CREATE DATABASE IF NOT EXISTS keycloak_staging;
            GRANT ALL PRIVILEGES ON keycloak_staging.* TO 'root'@'%';
            FLUSH PRIVILEGES;
            EOF

            # Stop existing services
            docker-compose -f docker-compose.staging.yml down || true

            # Build and start services
            docker-compose -f docker-compose.staging.yml up -d --build

            # Wait for services
            echo "Waiting for services to start..."
            sleep 60

            # Health checks
            echo "Checking MySQL..."
            docker-compose -f docker-compose.staging.yml exec -T mysql mysqladmin ping -h localhost --silent

            echo "Checking API..."
            for i in {1..10}; do
              if curl -f http://localhost:8081/health 2>/dev/null || curl -f http://localhost:8081/ 2>/dev/null; then
                echo "API is healthy!"
                break
              fi
              echo "Waiting for API... attempt $i/10"
              sleep 10
            done

            # Cleanup unused images
            docker image prune -f

      - name: Verify Staging Deployment
        run: |
          sleep 30
          curl -f http://${{ secrets.STAGING_HOST }}:8081/ || echo "API may still be starting"

  # Job 4: Deploy para Production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Deploy to Production Server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USERNAME }}
          key: ${{ secrets.PROD_PRIVATE_KEY }}
          port: ${{ secrets.PROD_PORT || 22 }}
          script: |
            # Create production directory
            mkdir -p ~/library-api-production
            cd ~/library-api-production

            # Backup current database if exists
            if docker-compose -f docker-compose.production.yml ps mysql 2>/dev/null | grep -q Up; then
              echo "Creating database backup..."
              docker-compose -f docker-compose.production.yml exec -T mysql \
                mysqldump -u root -p${{ secrets.PROD_MYSQL_PASSWORD }} --all-databases > \
                backup_$(date +%Y%m%d_%H%M%S).sql
            fi

            # Clone/update repository
            if [ -d ".git" ]; then
              git pull origin main
            else
              git clone -b main https://github.com/${{ github.repository }}.git .
            fi

            # Create production docker-compose
            cat > docker-compose.production.yml << 'EOF'
            services:
              app:
                build:
                  context: ${{ env.PROJECT_DIR }}
                  dockerfile: Dockerfile
                ports:
                  - "8080:5000"
                environment:
                  - ASPNETCORE_ENVIRONMENT=Production
                  - ASPNETCORE_URLS=http://+:5000
                  - ConnectionStrings__LibraryDatabase=Server=mysql;Port=3306;Database=librarydb_prod;User=root;Password=${{ secrets.PROD_MYSQL_PASSWORD }};
                  - Keycloak__Authority=http://keycloak:8080/realms/library
                  - Keycloak__Audience=library-client
                  - Keycloak__ClientId=library-client
                  - Keycloak__ClientSecret=${{ secrets.PROD_KEYCLOAK_SECRET }}
                depends_on:
                  - mysql
                  - keycloak
                restart: unless-stopped
                volumes:
                  - /var/log/library-api-prod:/app/logs
                  - /var/lib/library-api-prod:/app/data
                healthcheck:
                  test: ["CMD-SHELL", "curl -f http://localhost:5000/health || exit 1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              keycloak:
                image: quay.io/keycloak/keycloak:latest
                ports:
                  - "8090:8080"
                environment:
                  - KEYCLOAK_ADMIN=admin
                  - KEYCLOAK_ADMIN_PASSWORD=${{ secrets.PROD_KEYCLOAK_ADMIN_PASSWORD }}
                  - KC_DB=mysql
                  - KC_DB_URL=jdbc:mysql://mysql:3306/keycloak_prod
                  - KC_DB_USERNAME=root
                  - KC_DB_PASSWORD=${{ secrets.PROD_MYSQL_PASSWORD }}
                  - KC_HOSTNAME_STRICT=false
                  - KC_HOSTNAME_STRICT_HTTPS=false
                  - KC_HTTP_ENABLED=true
                command: start
                depends_on:
                  - mysql
                restart: unless-stopped
                volumes:
                  - keycloak_prod_data:/opt/keycloak/data

              mysql:
                image: mysql:8.0
                ports:
                  - "3306:3306"
                environment:
                  - MYSQL_ROOT_PASSWORD=${{ secrets.PROD_MYSQL_PASSWORD }}
                  - MYSQL_DATABASE=librarydb_prod
                volumes:
                  - mysql_prod_data:/var/lib/mysql
                  - ./init-prod-db.sql:/docker-entrypoint-initdb.d/init-prod-db.sql
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
                  interval: 30s
                  timeout: 10s
                  retries: 5

            volumes:
              mysql_prod_data:
              keycloak_prod_data:
            EOF

            # Create database initialization script
            cat > init-prod-db.sql << 'EOF'
            CREATE DATABASE IF NOT EXISTS keycloak_prod;
            GRANT ALL PRIVILEGES ON keycloak_prod.* TO 'root'@'%';
            FLUSH PRIVILEGES;
            EOF

            # Stop existing services gracefully
            docker-compose -f docker-compose.production.yml down || true

            # Build and start services
            docker-compose -f docker-compose.production.yml up -d --build

            # Extended wait for production services
            echo "Waiting for production services to start..."
            sleep 90

            # Comprehensive health checks
            echo "Checking MySQL..."
            for i in {1..15}; do
              if docker-compose -f docker-compose.production.yml exec -T mysql mysqladmin ping -h localhost --silent; then
                echo "MySQL is healthy!"
                break
              fi
              echo "Waiting for MySQL... attempt $i/15"
              sleep 10
            done

            echo "Checking Keycloak..."
            for i in {1..20}; do
              if curl -f http://localhost:8090/health/ready 2>/dev/null || curl -f http://localhost:8090/ 2>/dev/null; then
                echo "Keycloak is healthy!"
                break
              fi
              echo "Waiting for Keycloak... attempt $i/20"
              sleep 15
            done

            echo "Checking API..."
            for i in {1..15}; do
              if curl -f http://localhost:8080/health 2>/dev/null || curl -f http://localhost:8080/ 2>/dev/null; then
                echo "API is healthy!"
                break
              fi
              echo "Waiting for API... attempt $i/15"
              sleep 10
            done

            # Show running services
            docker-compose -f docker-compose.production.yml ps

            # Cleanup old images
            docker image prune -f

      - name: Verify Production Deployment
        run: |
          sleep 60
          curl -f http://${{ secrets.PROD_HOST }}:8080/ || echo "Production API may still be initializing"

      - name: Send Success Notification
        if: success()
        run: |
          echo "ðŸš€ Production deployment completed successfully!"
          echo "API: http://${{ secrets.PROD_HOST }}:8080"
          echo "Keycloak: http://${{ secrets.PROD_HOST }}:8090"

  # Job 5: Rollback (se falhar)
  rollback-production:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure() && github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Rollback Production
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USERNAME }}
          key: ${{ secrets.PROD_PRIVATE_KEY }}
          port: ${{ secrets.PROD_PORT || 22 }}
          script: |
            cd ~/library-api-production
            
            # Find the most recent backup
            BACKUP_FILE=$(ls -t backup_*.sql 2>/dev/null | head -1)
            
            if [ ! -z "$BACKUP_FILE" ]; then
              echo "Found backup: $BACKUP_FILE"
              echo "Rolling back to previous version..."
              
              # Stop current services
              docker-compose -f docker-compose.production.yml down
              
              # Restore database from backup
              docker-compose -f docker-compose.production.yml up -d mysql
              sleep 30
              
              cat $BACKUP_FILE | docker-compose -f docker-compose.production.yml exec -T mysql \
                mysql -u root -p${{ secrets.PROD_MYSQL_PASSWORD }}
              
              # Checkout previous commit
              git checkout HEAD~1
              
              # Restart all services
              docker-compose -f docker-compose.production.yml up -d --build
              
              echo "Rollback completed"
            else
              echo "No backup found for rollback"
            fi
